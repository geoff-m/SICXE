
The present software is of a modular design and has been written with OOP principles in mind. However, since SIC/XE has a complicated specification, my program is likewise multifaceted.
I will describe its operation in sequence and from a high level.

First, we are given the input text file, which we read line by line.
Although we could say the input file represents a SIC/XE program overall, the role of each line individually is a mystery.
The Program.TryParse method takes a path to the input file and attempts to return an instance of Program.
The "Program" type is little more than a list of Lines.
The most imoprtant action of Program.TryParse is to parse each line by calling Line.TryParse on all non-blank, non-comment lines.
In turn, Line.TryParse tries to parse the given string as either an instruction on an assembler directive--whichever works.
Once parsed, these are represented in my program as instances of the Instruction or AssemblerDirective types respectively, which are the two subclasses of the abstract Line.
Once an assumption for the type of line is fixed, actually parsing an AssemblerDirective is quite simple.
Instructions have a similar grammar to AssemblerDirectives, but parsing them is slightly more complicated due to the variety among instruction formats and the need to recognize {+ @ # ,}.
Once Program.TryParse returns, we have a complete representation of the input program in memory, and we know whether or not it obeys the syntactic rules for SIC/XE programs.

Assuming the input appears to be a valid program, we proceed by creating an instance of Assembler.
This instance will contain all the state we need to produce listing files for our particular program (including a reference thereto).
The PassOne method operates on the Program as before in a line-by-line fashion.
Each line is inspected to determine whether it is an AssemblerDirective or an Instruction.
In the case that the Line is an AssemblerDirective, the mnemonic determines how to handle it.
RESB and RESW have similar meanings, but every other directive is treated as pretty much a special case.
Instructions are much simpler to handle in pass one.
Overall, when PassOne returns, its two main jobs of setting each line's address and building a symbol table have been done.
PassOne also prints output as it processes each Line.

The program outputs the listing and symbol table to standard output, while the listing (with header) is also written to a file on disk.
This file will have the path of the input file with ".lst" appended.
The symbol table and any additional messages will be written to the standard error stream.